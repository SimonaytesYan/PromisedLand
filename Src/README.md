## Предисловие
Некоторые технические решения, реализованные в данном проекте могут показаться вам слишком громоздкими и излишними. Но нужно учитывать, что данный проект учебный и некоторый технологии(например, клетки, как плагины, сохранение и загрузка карты с помощью скриптового языка, использование самописного Vector) применены для того, чтобы продемонстрировать умение пользоваться данными технологиями.

## Структура проекта
* __Assets__ - папка с медиа файлами игры
* __Src__ - папка с исходными файлами
* __PluginObjects__ - папка с .so файлами, для системных плагинов
* __JitCompiler__ - исходные файлы JIT компилятора, использующегося для запуска скриптов
* __StlVector__ - исходные файлы реализации вектора близкого к stl vector
* __SystemPlugins__ - исходные файлы системных плагинов
* __Standart__ - интерфейсы, которые необходимы для написания плагинов 
* __Scripts__ - Папка с примерами скриптов, в том числе со скриптом сохранения(_Save.sym_)

Заголовочные файлы расположены в том же месте, где хранятся соответствующие им .cpp файлы. 

## Основные понятия
### Графика
В качестве графической библиотеки был выбран SFML. Для того, чтобы не работать с примитивами SFML напрямую было написано некоторое количество оболочек: [RenderTarget](Utils/RenderTarget.hpp), [Point](Utils/GraphicPrimitives.hpp), Texture(Utils/RenderTarget.hpp). 

Реализации классов, которые отображаются на экране, расположены в папке Graphics.
Каждый класс, который хочет быть нарисован на экране должен наследоваться от интерфейса [Renderable](Graphics/Renderable.hpp) или от [Widget](Graphics/Widget/Widget.hpp), который является наследником [Renderable](Graphics/Renderable.hpp). [Widget](Graphics/Widget/Widget.hpp) - основной класс в графике. И большая часть классов, отвечающие за визуальную часть проект, наследуются от Widget.

### Система событий
Система событий описана в файлах, расположенных в папке [Events](Events). Каждый класс, который хочет принимать события должен быть наследником интерфейса [Eventable](Events/Eventable.hpp).

Каждое событие должно быть наследником класса [Event](Events/Events.hpp).

### Игровая логика
Главные классы, отвечающие за игровую логику, - это [менеджеры](Managers).

Также важны классы, реализующие игровую логику [клеток](../SystemPlugins/). Каждая клетка - плагин. Их .so файлы лежат в [этой папке](PluginObjects). Все файлы, расположенные в этой папке интерпритируются как системные плагины клеток. 
Интерфейс, который должны поддерживать плагины описан в файлах папки [Standart](../Standart/)

### Взаимодействие графической и логической составляющих
При разработке архитектуры одним из самых важный постулатов было разделение графической и логической составляющей. Так у клетки поля есть графическое представление: [CellView](Graphics/CellView/CellView.hpp) - наследник виджета и логическое представление [Cell](../Standart/GameLogic/Cell.hpp)

Всё их взаимодействие осуществляется через передачу сообщений между объектами.
Чтобы передавать события между различными классами, существуют классы прослойки. Их реализации расположены в папке [Interlayers](Interlayers). 

Например, чтобы отправить событие из [CellView](Graphics/CellView/CellView.hpp) в [Cell](../Standart/GameLogic/Cell.hpp) необходимо отправить его в [CellViewGroup](Graphics/Widget/CellViewGroup.hpp), который через [CellInterlayer](Interlayers/CellInterlayer.cpp) отправит его в [CellManager](Managers/CellManager.cpp), который уже передаст нужное событие [Cell](../Standart/GameLogic/Cell.hpp).

Было установлено, что данная архитектура плохо подходит для данного проекта. Так как графической и логической составляющим нужно общаться очень часто, то происходит постоянный обмен событиями, а как видно из примера выше, это процесс достаточно длительный. Поэтому такая архитектура приводит к сильным потерям в скорости работы. В будущих версиях необходимо будет перейти на другую архитектуру.

### Сохранение и загрузка карты
Сохранение, загрузка и генерация карты описана в файлах, находящихся в папке [Map](Src/Map).

Файл сохранения - это скрипт на [языке программирования собственной разработки](https://github.com/SimonaytesYan/MyLanguage). Чтобы загрузить карту из файла происходит JIT компиляция и последующее исполнение этого файла. Методика JIT компиляции описана в [этом проекте](https://github.com/SimonaytesYan/BinaryTranslator).
